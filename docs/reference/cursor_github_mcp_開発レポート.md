# Cursor + GitHub MCP連携による開発実践レポート

## はじめに

このレポートは、Cursor AIとGitHub MCP（Model Context Protocol）を活用したチーム開発の実践記録です。プロジェクト初期設定から実際のPRレビュー・マージまで、一連のワークフローをまとめています。

**最も重要なポイント**: このレポートでは、**Cursor（AI）が実際に自動で行った作業**を詳しく記載しています。従来の「手動でやる」説明ではなく、「ユーザーが指示を出すだけで、AIが何を自動実行したか」を明確にしています。

**実際の成果**:
- Issue作成: 手動2時間 → Cursor自動5分（約96%削減）
- PRレビュー: 手動35分 → Cursor自動1分（約97%削減）
- ドキュメント作成: 約1500行を、指示だけで自動生成

**作成日**: 2026年1月10日  
**プロジェクト**: くんよみ（社内ナレッジ管理システム）

---

## 目次

1. [プロジェクト概要](#プロジェクト概要)
2. [初期設定と準備](#初期設定と準備)
3. [Cursor（AI）による自動化の実際](#cursoraiによる自動化の実際) ⭐
4. [GitHub MCP連携の活用](#github-mcp連携の活用)
5. [開発フローの確立](#開発フローの確立)
6. [Issue管理とチケットの切り方](#issue管理とチケットの切り方)
7. [PRレビューの実践（Cursorによる完全自動化）](#prレビューの実践cursorによる完全自動化) ⭐
8. [ドキュメント管理](#ドキュメント管理)
9. [学んだこと・ベストプラクティス](#学んだことベストプラクティス) ⭐
10. [実際の開発体験記](#実際の開発体験記)
11. [今後の改善点](#今後の改善点)

⭐マーク: Cursorによる自動化の実践例が詳しく記載されているセクション

---

## プロジェクト概要

### プロジェクト構成
- **フロントエンド**: Next.js (App Router), TypeScript, Tailwind CSS
- **バックエンド**: FastAPI, SQLAlchemy, Alembic
- **データベース**: MySQL (Azure Database for MySQL)
- **開発期間**: 2026年1月〜（3週間サイクル）

### チーム構成
- **メンバー**: 4名（多くがGitHub開発初心者）
- **開発スタイル**: 業務外でのパートタイム開発
- **コミュニケーション**: Slack + GitHub

---

## 初期設定と準備

### 1. GitHubリポジトリのセットアップ

#### リポジトリ作成
```bash
# ローカルでディレクトリ構造を整理
project_team11/
├── frontend/        # Next.jsアプリケーション
├── backend/         # FastAPIアプリケーション
├── docs/            # プロジェクトドキュメント
│   ├── setup/       # セットアップ関連
│   ├── design/      # 設計関連
│   └── tasks/       # タスク管理関連
└── minutes/         # ミーティング議事録
```

#### ディレクトリ構造の整理ポイント
- **フロントエンドとバックエンドを明確に分離**
- **ドキュメントをカテゴリ別に整理**（setup/design/tasks）
- **既存コードのリファレンス用ディレクトリ**（`frontend_figma/`）を作成

### 2. Issue/PRテンプレートの作成

#### Issueテンプレート（`.github/ISSUE_TEMPLATE/`）
- `task.md`: 開発タスク用
- `bug.md`: バグ報告用
- `feature.md`: 機能提案用

**テンプレートの基本構造**:
```markdown
## 目的
## スコープ
## 完了条件
## 依存関係
## 所要時間
```

#### ラベル設計（シンプルに）
**カテゴリ**:
- `backend`: バックエンド関連
- `frontend`: フロントエンド関連
- `documentation`: ドキュメント関連

**種類**:
- `task`: 開発タスク全般
- `bug`: バグ修正
- `enhancement`: 機能追加・改善

**優先度**（必要に応じて）:
- `high-priority`
- `low-priority`

**設計方針**: 初心者チームなので、煩雑な管理を避け、シンプルに保つ

### 3. `.gitignore`の設定

```gitignore
# Python
__pycache__/
*.py[cod]
venv/
.env

# Node.js
node_modules/
.next/
dist/

# OS
.DS_Store
Thumbs.db

# IDE
.vscode/
.idea/
*.swp
```

---

## GitHub MCP連携の活用

### MCPとは

**Model Context Protocol (MCP)** は、AIアシスタントが外部ツールやサービスと連携するためのプロトコルです。Cursorでは、GitHub MCPツールを通じて以下の操作が可能です。

### 実際に使用したMCPツール

#### 1. Issue管理
- `mcp_github_create_issue`: Issue作成
- `mcp_github_get_issue`: Issue詳細取得
- `mcp_github_list_issues`: Issue一覧取得
- `mcp_github_update_issue`: Issue更新

#### 2. Pull Request管理
- `mcp_github_create_pull_request`: PR作成
- `mcp_github_get_pull_request`: PR詳細取得
- `mcp_github_list_pull_requests`: PR一覧取得
- `mcp_github_merge_pull_request`: PRマージ

#### 3. レビュー機能
- `mcp_github_create_pull_request_review`: PRレビュー作成（Approve/Request changes/Comment）

#### 4. コード操作
- `mcp_github_get_file_contents`: ファイル内容取得
- `mcp_github_create_or_update_file`: ファイル作成・更新

### MCP活用のメリット

1. **コンテキスト保持**: Cursor内で完結するため、開発フローが途切れない
2. **一貫性**: すべての操作が同じインターフェースから実行可能
3. **効率化**: Issue作成からPRマージまで、対話形式で進められる
4. **エラー防止**: 必要なパラメータをAIが確認しながら進める

### 実際の使用例

#### Issue作成の例
```
ユーザー: "Week1のタスクをIssueにしてほしい"
→ Cursorがタスク分割ドキュメントを読み込み
→ Issueテンプレートに従って各タスクをIssue化
→ 日本語タイトル・説明で作成
→ 適切なラベルとアサインを設定
```

#### PRレビューの例
```
ユーザー: "他のメンバーからのPRをレビューしたい"
→ CursorがPRを取得
→ ローカルでブランチをチェックアウト
→ コードを確認・テスト実行
→ レビューコメントとApproveを自動生成
```

---

## Cursor（AI）による自動化の実際

### 設計思想

**重要な原則**: 「何をしたいか」を言葉で伝えるだけで、Cursorが実行までの一連の流れを自動化する

- **手動コマンドを覚える必要がない**: Gitコマンド、GitHub CLI、テストコマンドなど、すべてCursorが実行
- **コンテキストの自動把握**: 関連ファイルを自動で読み込み、状況を理解
- **エラー時の自動対処**: エラーが発生したら、原因を分析して修正案を提示・実行

### 実際にCursorが自動で行ったこと

#### 1. タスク分割ドキュメントの自動作成

**ユーザーのプロンプト**:
```
"Week1のタスク分割案を作ってくれない？"
```

**Cursorが自動で実行したこと**:
- ミーティング議事録を読み込み、Week1の目標を把握
- データ定義ドキュメントを参照して、実装すべき機能を理解
- フェーズ0（基盤整備）からフェーズ2（フロントエンド接続）まで、依存関係を考慮して分割
- 各タスクに所要時間、依存関係、完了条件を自動で設定
- `docs/tasks/task_breakdown_week1.md` を作成

**所要時間**: ユーザーは指示を出すだけ（約1分）、Cursorが自動処理（約2-3分）

#### 2. Issue一括作成の自動化

**ユーザーのプロンプト**:
```
"Week1のタスクをIssueにしてほしい。
日本語タイトルで、アサインは決まっているものだけ。
ラベルも適切につけて"
```

**Cursorが自動で実行したこと**:
- `docs/tasks/task_breakdown_week1.md` を読み込み
- 各タスクをIssueテンプレートに従ってIssue化
- GitHub MCP APIを通じて、複数のIssueを一括作成
- 適切なラベル（`backend`/`frontend`/`task`など）を自動設定
- アサイン可能なタスクには自動でアサイン
- Issue番号とURLを返却

**実際の結果**: 
- 12個のIssueを約5分で一括作成
- 手動でやると1つ10分として約2時間かかるところを、大幅に短縮

#### 3. プロジェクト構造の自動整理

**ユーザーのプロンプト**:
```
"ディレクトリ構造も考えてみてほしい。
このままだと最上位階層にフロントエンドのpackage.jsonがあるから、
それはおかしいから、ちょっといじる必要はあると思うけど。
ここら辺の案も含めて"
```

**Cursorが自動で実行したこと**:
- 既存のディレクトリ構造を分析
- フロントエンドとバックエンドの明確な分離を提案
- ドキュメントのカテゴリ別整理（setup/design/tasks）を提案
- 既存コードのリファレンス用ディレクトリ（`frontend_figma/`）の作成を提案
- `.gitignore`の自動生成
- `README.md`の更新

**ユーザーがやったこと**: 提案を承認するだけ

#### 4. ドキュメントの自動作成・更新

**ユーザーのプロンプト**:
```
"基本的な運用ルールみたいなところをわかりやすく記載した手順書を作ってほしい。
というのもみんなGithubを使った開発は2回目ぐらいの感じで、慣れてないのは事実だから"
```

**Cursorが自動で実行したこと**:
- プロジェクトの状況を把握（初心者チーム、GitHub経験少ない）
- GitHubワークフローの全体像を理解
- 実際のコマンド例を含む詳細な手順書を作成
- よくある質問とトラブルシューティングを自動生成
- チェックリストを作成
- `docs/setup/github_workflow.md` を作成（約480行）

**同様に自動作成されたドキュメント**:
- `docs/setup/setup.md`: 開発環境セットアップ（約180行）
- `docs/setup/week1_development_guide.md`: Week1開発ガイド（約350行）
- `docs/project_structure.md`: プロジェクト構造と開発フロー
- `docs/design/feature_roadmap.md`: 機能ロードマップ

**合計**: 約1500行以上のドキュメントを、ユーザーの指示だけで自動生成

#### 5. PRレビューの完全自動化

**ユーザーのプロンプト**:
```
"ローカルで確認しよう。Issueが#10ね。内容をきちんと反映されているかをテストしたい。"
```

**Cursorが自動で実行したこと**:

1. **Issue #10の内容を自動取得**
   - GitHub MCP APIでIssue詳細を取得
   - 要件（エンドポイント、正規化処理、ソート順）を把握

2. **PRを自動検索・取得**
   - オープンなPR一覧を取得
   - Issue #10に関連するPRを特定（PR #23）
   - PRの変更内容を取得

3. **ローカル環境の自動準備**
   ```bash
   git fetch origin
   git checkout -b review/phase1-keywords-api origin/feature/phase1-keywords-api
   ```

4. **依存関係の確認・インストール**
   - `requirements.txt`を確認
   - 不足している依存関係を自動インストール

5. **サーバーの自動起動**
   ```bash
   cd backend
   source venv/bin/activate
   uvicorn app.main:app --reload &
   ```

6. **テストデータの自動投入**
   - データベースに接続
   - 既存データを確認
   - テスト用データを自動生成・投入

7. **自動テスト実行**
   - 一覧取得APIのテスト
   - 検索APIのテスト（複数パターン）
   - 正規化処理のテスト（全角・大文字小文字）
   - バリデーションテスト（空文字列）
   - 各テストの結果を記録

8. **テスト結果の自動まとめ**
   - 要件との対応関係を自動チェック
   - 表形式で結果を整理
   - 問題点があれば指摘

9. **レビューコメントの自動生成**
   - テスト結果を基にレビューコメントを作成
   - マークダウン形式でフォーマット

**ユーザーがやったこと**: 「ローカルで確認しよう」と指示するだけ

**実際の結果**:
- 約30分のレビュー作業を、ユーザーは指示を出すだけで完了
- テスト実行からレビューコメント作成まで、すべて自動化

#### 6. コード実装の自動生成（Phase 0の例）

**ユーザーのプロンプト**:
```
"0-1に行こう。バックエンドプロジェクト作成"
```

**Cursorが自動で実行したこと**:
- FastAPIプロジェクトの基本構造を理解
- `backend/app/main.py` を作成（FastAPIアプリ、ヘルスチェックエンドポイント）
- `backend/app/__init__.py` を作成
- `backend/requirements.txt` を作成（適切なバージョン指定）
- `.env.example` を作成
- 基本的なディレクトリ構造を提案・作成

**ユーザーがやったこと**: 指示を出すだけ

**同様に自動実装されたもの**:
- Phase 0-2: データベース接続設定（`app/db.py`の作成、`.env`の設定例）
- Phase 0-3: DBモデル定義（全テーブルのモデルファイル、リレーションシップ）
- Phase 0-4: 初期データ投入スクリプト（ジャンルマスターデータ）
- Phase 0-5: APIクライアント関数（TypeScript、型定義付き）

#### 7. エラー時の自動対処

**実際の例: Pythonコマンドエラー**

**ユーザーの報告**:
```
"pythonが見つからないってどういうことだ？"
```

**Cursorが自動で実行したこと**:
- エラーメッセージを分析（macOS環境）
- macOSでは`python3`を使用する必要があることを判断
- ユーザーに`python3`を使うよう説明
- 以降のコマンドをすべて`python3`に自動修正

**実際の例: データベース接続エラー**

**エラー発生時**:
- エラーメッセージを読み取り
- 原因を特定（.envファイルが存在しない）
- `.env.example`から`.env`を作成する手順を提示
- 必要に応じて自動実行

### 開発フローの実際（Cursor自動化版）

```
1. ユーザー: "タスク分割して" 
   → Cursor: タスク分割ドキュメントを自動作成

2. ユーザー: "Issueにして" 
   → Cursor: 複数Issueを一括作成

3. ユーザー: "0-1をやろう" 
   → Cursor: コードを自動生成・実装

4. ユーザー: "PRレビューして" 
   → Cursor: ローカル確認・テスト実行・レビューコメント作成まで自動

5. ユーザー: "マージして" 
   → Cursor: PRをマージ・ローカル更新まで自動
```

**従来の手動フローとの比較**:
- **Issue作成**: 手動2時間 → Cursor自動5分
- **PRレビュー**: 手動30分 → Cursor自動（指示だけ）
- **ドキュメント作成**: 手動数時間 → Cursor自動（指示だけ）
- **エラー対処**: 手動調査・修正 → Cursor自動分析・修正提案

### ブランチ戦略

#### 命名規則
- `feature/issue-{番号}-{簡潔な説明}`: 機能開発用
- `fix/issue-{番号}-{説明}`: バグ修正用
- `review/{ブランチ名}`: レビュー用（一時的）

**例**:
- `feature/issue-10-keywords-api`
- `review/phase1-keywords-api`

#### ブランチ管理
- **mainブランチ**: 直接コミット禁止（必ずPR経由）
- **featureブランチ**: 1Issue = 1ブランチ
- **レビュー用ブランチ**: レビュー後に削除

### コミットメッセージ

#### 基本形式
```
[Issue #X] 簡潔な説明
```

**例**:
- `[Issue #10] キーワード検索APIの実装`
- `[Issue #5] APIクライアント関数の作成（フロントエンド）`
- `docs: setup.mdにNext.jsデフォルトページの注意書きを追加`

---

## Issue管理とチケットの切り方

### タスク分割のプロセス

#### 1. 大まかなフェーズ分割
```
フェーズ0: 基盤整備（@しゅんすけ主導）
フェーズ1: バックエンドAPI実装（並行可能）
フェーズ2: フロントエンド接続（並行可能）
```

#### 2. 各フェーズの細分化

**フェーズ0の例**:
- 0-1: バックエンドプロジェクト作成
- 0-2: データベース接続設定
- 0-3: DBモデル定義（全テーブル）
- 0-4: 初期データ投入（ジャンルマスター）
- 0-5: APIクライアント関数の作成（フロントエンド）

**各タスクに含める情報**:
- 所要時間の見積もり
- 依存関係（どのタスクの完了が必要か）
- 担当者（明確な場合はアサイン）
- 完了条件（何をもって完了とするか）

#### 3. Issue化

**Issueテンプレートに基づいて作成**:
```markdown
## 目的
キーワードの一覧取得と検索を行うAPIエンドポイントを実装する

## スコープ
- `GET /api/keywords` エンドポイント実装（一覧取得）
- `GET /api/keywords/search?q={query}` エンドポイント実装（検索）
- 正規化処理（NFKC Normalize、ケースフォールディング）
- 使用回数順でのソート

## 完了条件
- APIが動作し、キーワード一覧・検索ができる
- 正規化処理が正しく動作する

## 依存関係
- #3 [フェーズ0] DBモデル定義（全テーブル） が完了していること

## 所要時間
1時間
```

### Issue作成の実際の流れ

1. **タスク分割ドキュメントを準備**
   - `docs/tasks/task_breakdown_week1.md` を作成
   - 各タスクの詳細を記載

2. **Cursorに指示**
   ```
   "Week1のタスクをIssueにしてほしい。
   日本語タイトルで、アサインは決まっているものだけ。
   ラベルも適切につけて"
   ```

3. **Cursorが自動処理**
   - タスク分割ドキュメントを読み込み
   - 各タスクをIssue化
   - テンプレートに従って作成
   - ラベルとアサインを設定

4. **確認・調整**
   - 作成されたIssueを確認
   - 必要に応じて修正

---

## PRレビューの実践（Cursorによる完全自動化）

### 実際のレビューフロー: Issue #10の例

#### ユーザーのプロンプト
```
"ローカルで確認しよう。Issueが#10ね。内容をきちんと反映されているかをテストしたい。"
```

これだけの指示で、Cursorが以下をすべて自動実行しました。

#### ステップ1: Issue内容の自動取得と理解

**Cursorが自動で実行**:
```javascript
// GitHub MCP APIでIssue #10を取得
mcp_github_get_issue({
  owner: "Shun0914",
  repo: "kunyomi",
  issue_number: 10
})
```

**取得した情報**:
- 目的: キーワードの一覧取得と検索API
- スコープ: 
  - `GET /api/keywords`（一覧取得）
  - `GET /api/keywords/search?q={query}`（検索）
  - 正規化処理（NFKC + ケースフォールディング）
  - 使用回数順でのソート
- 完了条件: APIが動作し、正規化処理が正しく動作する

#### ステップ2: PRの自動検索・取得

**Cursorが自動で実行**:
```javascript
// オープンなPR一覧を取得
mcp_github_list_pull_requests({
  owner: "Shun0914",
  repo: "kunyomi",
  state: "open"
})
```

**結果**: PR #23がIssue #10に関連することを特定
- タイトル: "Add keyword list/search API(#10)"
- ブランチ: `feature/phase1-keywords-api`

#### ステップ3: ローカル環境の自動準備

**Cursorが自動で実行したコマンド**:
```bash
# リモートの最新情報を取得
git fetch origin

# レビュー用ブランチを作成・チェックアウト
git checkout -b review/phase1-keywords-api origin/feature/phase1-keywords-api

# 現在のブランチを確認
git branch --show-current  # → review/phase1-keywords-api

# 変更内容を確認
git diff main...review/phase1-keywords-api --stat
git diff main...review/phase1-keywords-api
```

**確認した変更**:
- `backend/app/main.py`: ルーター登録追加
- `backend/app/routers/keywords.py`: 新規作成（41行）
- `backend/app/schemas/keyword.py`: 新規作成（12行）

#### ステップ4: 依存関係の確認・インストール

**Cursorが自動で実行**:
```bash
cd backend
source venv/bin/activate
pip install -q sqlalchemy pymysql cryptography
```

#### ステップ5: サーバーの自動起動

**Cursorが自動で実行**:
```bash
uvicorn app.main:app --reload --host 0.0.0.0 --port 8000 > /tmp/uvicorn.log 2>&1 &
sleep 3
curl http://localhost:8000/health  # → {"status":"healthy"}
```

#### ステップ6: テストデータの自動投入

**Cursorが自動で実行**:
```python
# Pythonスクリプトを自動生成・実行
# 既存データを確認
# テストデータを投入（React, Python, FastAPI, TypeScript）
# 使用回数を設定（ソート確認のため）
```

**投入したデータ**:
- React (usage_count: 15)
- Python (usage_count: 10)
- FastAPI (usage_count: 8)
- TypeScript (usage_count: 5)

#### ステップ7: 自動テスト実行

**Cursorが自動で実行したテスト**:

1. **一覧取得APIテスト**
   ```bash
   curl http://localhost:8000/api/keywords
   ```
   **確認点**: 使用回数順（DESC）でソートされているか
   **結果**: ✅ 正しくソートされている（React > Python > FastAPI > TypeScript）

2. **検索APIテスト（部分一致）**
   ```bash
   curl "http://localhost:8000/api/keywords/search?q=react"
   ```
   **結果**: ✅ 正常に検索できた

3. **検索APIテスト（大文字）**
   ```bash
   curl "http://localhost:8000/api/keywords/search?q=REACT"
   ```
   **確認点**: 正規化処理が動作しているか（大文字→小文字）
   **結果**: ✅ 正常に検索できた（正規化処理が動作）

4. **検索APIテスト（全角文字）**
   ```bash
   curl "http://localhost:8000/api/keywords/search?q=Ｐｙｔｈｏｎ"
   ```
   **確認点**: 全角文字も検索できるか（NFKC正規化）
   **結果**: ✅ 正常に検索できた

5. **検索APIテスト（部分一致2）**
   ```bash
   curl "http://localhost:8000/api/keywords/search?q=fast"
   ```
   **結果**: ✅ "FastAPI"が検索できた

6. **バリデーションテスト（空文字列）**
   ```bash
   curl "http://localhost:8000/api/keywords/search?q="
   ```
   **確認点**: 適切なエラーが返るか
   **結果**: ✅ バリデーションエラーが返ってきた（`string_too_short`）

7. **正規化処理の詳細テスト**
   ```python
   # normalize_text関数を直接テスト
   normalize_text("Python")   # → "python" ✅
   normalize_text("PYTHON")   # → "python" ✅
   normalize_text("Ｐｙｔｈｏｎ")  # → "python" ✅
   ```
   **結果**: ✅ すべて正常に動作

#### ステップ8: テスト結果の自動まとめ

**Cursorが自動で作成したまとめ**:

| 要件 | 状態 | 確認内容 |
|------|------|----------|
| `GET /api/keywords` エンドポイント | ✅ 実装済み | 一覧取得が動作し、使用回数順でソートされている |
| `GET /api/keywords/search?q={query}` エンドポイント | ✅ 実装済み | 検索が動作し、部分一致も対応 |
| 正規化処理（NFKC + ケースフォールディング） | ✅ 実装済み | 大文字・全角文字も正しく検索可能 |
| 使用回数順でのソート | ✅ 実装済み | DESC順で正しくソートされている |
| バリデーション | ✅ 実装済み | 空文字列で適切なエラーを返す |

#### ステップ9: レビューコメントの自動生成

**Cursorが自動で作成したレビューコメント**:
```markdown
## レビュー結果

Issue #10の要件を全て満たしており、実装も適切です。ローカル環境でテストを実施し、以下の点を確認しました。

### ✅ 要件確認
- [x] `GET /api/keywords` エンドポイント実装（一覧取得）
- [x] `GET /api/keywords/search?q={query}` エンドポイント実装（検索）
- [x] 正規化処理（NFKC Normalize、ケースフォールディング）
- [x] 使用回数順でのソート

### ✅ テスト結果
1. **一覧取得（使用回数順）**: 使用回数の降順で正しくソートされていることを確認
2. **検索機能**: 部分一致検索が正常に動作、大文字・小文字の区別なく検索可能
3. **正規化処理**: 全角文字（`Ｐｙｔｈｏｎ`）も正しく検索可能、大文字（`REACT`）も正しく検索可能
4. **バリデーション**: 空文字列で適切なエラーレスポンスを返す

### ✅ コード品質
- ルーター構造が適切
- レスポンススキーマが定義されている
- `main.py`にルーターが正しく登録されている
- エラーハンドリングが実装されている

素晴らしい実装です！🎉
```

#### ステップ10: Approveの自動提出

**Cursorが自動で実行**:
```javascript
mcp_github_create_pull_request_review({
  owner: "Shun0914",
  repo: "kunyomi",
  pull_number: 23,
  body: "上記のレビューコメント",
  event: "APPROVE"
})
```

#### ステップ11: クリーンアップ

**Cursorが自動で実行**:
```bash
# サーバーを停止
pkill -f "uvicorn app.main:app"

# mainブランチに戻る
git checkout main

# レビュー用ブランチを削除
git branch -d review/phase1-keywords-api
```

### ユーザーがやったこと

**たった1つのプロンプト**: "ローカルで確認しよう。Issueが#10ね。内容をきちんと反映されているかをテストしたい。"

**結果**: 
- 約30分のレビュー作業が完了
- テスト実行からレビューコメント作成、Approve提出まで、すべて自動化
- ユーザーは結果を確認するだけ

### 従来の手動レビューとの比較

**従来の手動レビュー**:
1. PRページを開く（1分）
2. コードを目視確認（10分）
3. ローカルにブランチをチェックアウト（2分）
4. サーバーを起動（1分）
5. テストデータを準備（5分）
6. 手動でAPIをテスト（10分）
7. レビューコメントを書く（5分）
8. Approveボタンを押す（1分）
**合計**: 約35分

**Cursor自動化**:
1. プロンプトを入力（10秒）
2. 結果を確認（1分）
**合計**: 約1分10秒

**時間短縮**: 約97%削減

### レビューで発見したポイント（Cursorが自動で確認）

1. **正規化処理の確認**: 全角文字や大文字小文字の区別が正しく動作しているか
2. **エラーハンドリング**: バリデーションが適切に実装されているか
3. **レスポンススキーマ**: 型定義が正しく反映されているか
4. **ルーター登録**: `main.py`にルーターが正しく登録されているか

---

## ドキュメント管理

### ドキュメント構造

```
docs/
├── setup/                    # セットアップ関連
│   ├── setup.md             # 開発環境セットアップ
│   ├── github_workflow.md   # GitHubワークフロー手順
│   └── week1_development_guide.md  # Week1開発ガイド
├── design/                   # 設計関連
│   ├── er_diagram.md        # ER図
│   ├── data_definition.md   # データ定義
│   ├── feature_roadmap.md   # 機能ロードマップ
│   └── genre_master_data.md # ジャンルマスターデータ
└── tasks/                    # タスク管理
    └── task_breakdown_week1.md  # Week1タスク分割
```

### ドキュメント作成のポイント

#### 1. 要件のまとめ方

**データ定義ドキュメントの例**:
- テーブルごとにカラム定義を明記
- データ型、NULL許可、デフォルト値を記載
- リレーションシップを図示（ER図）
- 設計判断とその理由を記録

**重要なポイント**:
- **決定事項と未決定事項を明確に区別**
- **設計判断の背景を記録**（後で理由を思い出せるように）
- **変更履歴を残す**（v0.1, v0.2...）

#### 2. 開発ガイドの作成

**`week1_development_guide.md`の構成**:
```markdown
## 1. 環境セットアップ
## 2. API実装の基本構造
## 3. 実装例（Genre API）
## 4. テスト方法
   - Swagger UI
   - curl
## 5. よくある質問
   - CORS設定
   - エラーハンドリング
## 6. チェックリスト
```

**初心者向けのポイント**:
- **具体的なコード例を多数掲載**
- **よくあるエラーと解決方法を記載**
- **ステップバイステップで説明**

#### 3. GitHubワークフロー手順書

**`github_workflow.md`の構成**:
```markdown
## 1. GitHubの基本用語
## 2. 開発の全体フロー
## 3. ステップバイステップ手順
   - Issueを選ぶ
   - ブランチ作成
   - コードを書く
   - コミット・プッシュ
   - PR作成
   - レビュー待ち
   - マージ後
## 4. よくある質問
## 5. トラブルシューティング
## 6. チェックリスト
```

**重要なポイント**:
- **実際のコマンドをそのまま記載**
- **エラーメッセージと解決方法を対応付ける**
- **初心者が躓きやすいポイントを重点的に説明**

### ドキュメントの更新タイミング

1. **設計変更時**: データ定義やER図を更新
2. **新機能追加時**: 開発ガイドに例を追加
3. **問題発生時**: トラブルシューティングセクションに追加
4. **プロセス改善時**: ワークフロー手順書を更新

---

## 学んだこと・ベストプラクティス

### 1. 「何をしたいか」を言葉で伝えるだけで良い

**最も重要な学び**:
- **コマンドを覚える必要がない**: Gitコマンド、GitHub CLI、テストコマンドなど、すべてCursorが実行
- **コンテキストを自動把握**: 関連ファイルを自動で読み込み、状況を理解してから行動
- **エラー時の自動対処**: エラーが発生したら、原因を分析して修正案を提示・実行

**実際の例**:
```
ユーザー: "ローカルで確認しよう。Issueが#10ね。内容をきちんと反映されているかをテストしたい。"

→ Cursorが自動で:
   1. Issue #10の内容を取得・理解
   2. 関連するPRを検索・特定
   3. ローカルにブランチをチェックアウト
   4. 依存関係を確認・インストール
   5. サーバーを起動
   6. テストデータを準備・投入
   7. APIをテスト実行（複数パターン）
   8. テスト結果をまとめる
   9. レビューコメントを作成
   10. Approveを提出
```

**従来の方法との比較**:
- **従来**: 各ステップを手動で実行（約35分）
- **Cursor**: プロンプト1つで完了（約1分）
- **時間短縮**: 約97%

### 2. AIによる自動化の設計思想

**設計原則**:
1. **対話的な自動化**: 「何をしたいか」を自然言語で伝えるだけで、AIが実行までの流れを自動化
2. **コンテキストの自動保持**: 会話の流れを理解し、前後の文脈を考慮
3. **エラー時の自動対処**: 問題が発生したら、原因を分析して解決策を提示・実行
4. **段階的な確認**: 重要な操作（マージなど）は確認を求める

**実際のプロンプト例**:

#### タスク分割の例
```
"Week1のタスク分割案を作ってくれない？"
→ Cursorが議事録・データ定義を読み込み、依存関係を考慮して自動分割
```

#### Issue作成の例
```
"Week1のタスクをIssueにしてほしい。日本語タイトルで、アサインは決まっているものだけ。"
→ Cursorがタスク分割を読み込み、12個のIssueを一括作成（約5分）
```

#### コード実装の例
```
"0-1に行こう。バックエンドプロジェクト作成"
→ CursorがFastAPIプロジェクト構造を理解し、必要なファイルを自動作成
```

#### ドキュメント作成の例
```
"基本的な運用ルールみたいなところをわかりやすく記載した手順書を作ってほしい。
みんなGithubを使った開発は2回目ぐらいの感じで、慣れてないのは事実だから"
→ Cursorがプロジェクト状況を理解し、初心者向けの詳細な手順書を作成（約480行）
```

### 3. タスク分割の重要性（AIによる自動化）

**学び**:
- 大きなタスクを小さく分割することで、並行開発が可能になる
- 依存関係を明確にすることで、ブロッキングを防げる
- **AIが自動で依存関係を分析し、適切に分割してくれる**

**実践**:
- ユーザー: "Week1のタスク分割案を作って"
- Cursor: 議事録・データ定義を読み込み、フェーズ0-2まで自動分割
- Phase 0（基盤）は1人が主導し、完了後にPhase 1（API実装）を並行開発
- 各APIエンドポイントは独立しているため、複数人で同時に実装可能

### 4. ドキュメント先行の価値（AIによる自動生成）

**学び**:
- 設計を先に文書化することで、実装時の迷いが減る
- **AIが自動でドキュメントを生成してくれるため、負担が大幅に軽減**
- チーム全体の認識統一がしやすい

**実践**:
- ER図とデータ定義を先に作成（ユーザーが要件を伝えるだけ）
- 開発ガイドで実装パターンを共有（Cursorがコード例を含めて自動生成）
- ワークフロー手順書でGitHub操作を統一（約480行を自動生成）
- **合計約1500行のドキュメントを、指示だけで自動生成**

### 5. シンプルな管理の重要性

**学び**:
- 初心者チームでは、複雑な管理ツールは逆効果
- ラベルやマイルストーンは最小限に
- **AIが自動で適切なラベルを設定してくれるため、管理が簡単**

**実践**:
- ラベルは3カテゴリ + 3種類のみ（合計6種類）
- GitHub Projectsで管理（Kanbanボード）
- Issueテンプレートはシンプルに
- **Issue作成時に、Cursorが自動で適切なラベルを設定**

### 6. レビューの実践（AIによる完全自動化）

**学び**:
- ローカルで実際に動かすことで、見落としが減る
- **AIが自動でテストを実行し、結果をまとめてくれるため、品質が向上**
- ポジティブなフィードバックも重要

**実践**:
- ユーザー: "PRをレビューしたい"
- Cursor: PR取得 → ローカル確認 → テスト実行 → レビューコメント作成 → Approve提出
- **約30分のレビュー作業が、指示1つで完了**
- テスト結果をレビューコメントに自動記載
- 良い点も積極的に指摘（自動生成）

### 7. エラー時の自動対処

**実際の例1: Pythonコマンドエラー**

**ユーザー**: "pythonが見つからないってどういうことだ？"

**Cursorが自動で実行**:
- エラーメッセージを分析
- macOS環境を認識
- `python3`を使う必要があることを判断
- 以降のコマンドをすべて`python3`に自動修正

**実際の例2: データベース接続エラー**

**エラー発生時**:
- Cursorがエラーメッセージを読み取り
- 原因を特定（.envファイルが存在しない）
- `.env.example`から`.env`を作成する手順を提示
- 必要に応じて自動実行

**実際の例3: PR作成時のエラー**

**エラー**: "No commits between main and feature/xxx"

**Cursorが自動で対処**:
- 原因を特定（mainブランチに直接コミットしてしまった）
- 解決策を提示（revert → ブランチ作成 → 再コミット）
- 実行手順を自動化
- 正常なPRを作成

### 8. コミュニケーションの改善

**学び**:
- **AIが会話の文脈を理解し、必要な情報を自動で取得**
- 質問に対して、関連ドキュメントを自動で参照して回答
- 曖昧な指示でも、前後の文脈から意図を推測

**実践**:
- ユーザー: "これってどうすればいい？"
- Cursor: 関連ファイルを自動で読み込み、状況を把握して回答
- ドキュメントの参照を自動で行うため、正確な情報を提供

---

## 今後の改善点

### 1. テストの自動化

**現状**:
- ローカルでの手動テストのみ

**改善案**:
- pytest/unittestで自動テストを書く
- GitHub ActionsでCI/CDを構築
- PR作成時に自動でテストが実行されるようにする

### 2. コードレビューの効率化

**現状**:
- レビューは手動で実施

**改善案**:
- レビューチェックリストをテンプレート化
- 自動リント（flake8, black等）を導入
- コードカバレッジを測定

### 3. ドキュメントの自動生成

**現状**:
- 手動でドキュメントを更新

**改善案**:
- APIドキュメントをSwagger/OpenAPIから自動生成
- コードコメントからドキュメント生成
- 変更履歴を自動で更新

### 4. コミュニケーションの改善

**現状**:
- SlackとGitHubのIssue/PRでコミュニケーション

**改善案**:
- PRに自動でSlack通知
- Issue作成時に担当者に通知
- デイリースタンドアップ用の自動レポート

### 5. デプロイの自動化

**現状**:
- デプロイは手動（予定）

**改善案**:
- mainブランチへのマージで自動デプロイ
- ステージング環境と本番環境を分離
- ロールバック機能の実装

---

## 実際の開発体験記

### Phase 0: 基盤整備（1週間）

#### ユーザーがやったこと
各フェーズで、ユーザーは「〜をやって」と指示するだけ

#### Cursorが自動で実施したこと

**Phase 0-1: バックエンドプロジェクト作成**
- **ユーザーの指示**: "0-1に行こう。バックエンドプロジェクト作成"
- **Cursorが自動実行**:
  - FastAPIプロジェクト構造を理解
  - `backend/app/main.py`を作成（FastAPIアプリ、ヘルスチェックエンドポイント）
  - `backend/app/__init__.py`を作成
  - `backend/requirements.txt`を作成（適切なバージョン指定）
  - `.env.example`を作成
  - 基本的なディレクトリ構造を提案・作成

**Phase 0-2: データベース接続設定**
- **ユーザーの指示**: "0-2に行こう。データベース接続設定"
- **Cursorが自動実行**:
  - `backend/app/db.py`を作成（SQLAlchemy設定）
  - 環境変数の設定例を`.env.example`に追加
  - 接続テスト用のヘルスチェックエンドポイントを追加
  - セットアップドキュメントを更新

**Phase 0-3: DBモデル定義（全テーブル）**
- **ユーザーの指示**: "0-3に行こう。DBモデル定義"
- **Cursorが自動実行**:
  - データ定義ドキュメントを読み込み
  - 全テーブルのモデルファイルを作成（User, Genre, Keyword, Document, DocumentKeyword）
  - リレーションシップを定義
  - Alembicを初期化
  - マイグレーションファイルを生成
  - `updated_at`カラムの`ON UPDATE CURRENT_TIMESTAMP`を後で修正（別のマイグレーションで）

**Phase 0-4: 初期データ投入（ジャンルマスター）**
- **ユーザーの指示**: "0-4に行こう。ジャンルマスターの初期データ"
- **Cursorが自動実行**:
  - ジャンル構造を設計（ビジネス指向の階層構造）
  - `docs/design/genre_master_data.md`を作成
  - データ投入スクリプト（`backend/scripts/init_genres.py`）を作成
  - 既存データチェック機能を実装
  - 26件のジャンルデータを定義

**Phase 0-5: APIクライアント関数作成（フロントエンド）**
- **ユーザーの指示**: "0-5に行こう。APIクライアント関数の作成"
- **Cursorが自動実行**:
  - 型定義ファイル（`frontend/types/knowledge.ts`）を作成
  - APIクライアントのベース（`frontend/lib/api/client.ts`）を作成
  - 各エンドポイント用の関数を作成（documents, genres, keywords）
  - エラーハンドリングを実装

#### 学んだこと（Cursorによる自動化の価値）
- **Alembicの重要性**: マイグレーション管理が必須（Cursorが自動で設定）
- **環境変数の管理**: `.env`ファイルで統一（Cursorが`.env.example`を自動作成）
- **モデル定義の順序**: 依存関係を考慮して定義する順番を決める（Cursorが自動で分析）

### Issue #10: キーワード検索API実装とレビュー

#### 実装内容（メンバーが実装）
- `GET /api/keywords`: 一覧取得（使用回数順）
- `GET /api/keywords/search?q={query}`: 検索（正規化処理付き）

#### PRレビューの完全自動化（Cursorが実施）

**ユーザーの指示**: "ローカルで確認しよう。Issueが#10ね。内容をきちんと反映されているかをテストしたい。"

**Cursorが自動で実行したこと**:
1. Issue #10の内容を取得・理解
2. 関連するPR #23を検索・特定
3. ローカルにブランチをチェックアウト
4. 変更内容を確認（diff表示）
5. 依存関係を確認・インストール
6. サーバーを起動
7. テストデータを準備・投入（React, Python, FastAPI, TypeScript）
8. APIをテスト実行:
   - 一覧取得API（使用回数順の確認）
   - 検索API（部分一致、大文字、全角文字、バリデーション）
   - 正規化処理の詳細テスト
9. テスト結果をまとめる（表形式）
10. レビューコメントを作成（要件確認、テスト結果、コード品質評価）
11. Approveを提出
12. クリーンアップ（サーバー停止、ブランチ削除）

#### レビューで確認したこと（Cursorが自動で確認）
1. 正規化処理（NFKC + ケースフォールディング）が正しく動作
2. 全角文字（`Ｐｙｔｈｏｎ`）も検索可能
3. バリデーション（空文字列エラー）が適切
4. レスポンススキーマが正しく定義されている

#### PR #23の流れ（Cursorによる自動化）
1. PR作成（メンバー）
2. **Cursorが自動実行**: ローカルでレビューブランチ作成 → コード確認 → テスト実行 → レビューコメント作成 → Approve提出
3. **ユーザーの指示**: "マージして"
4. **Cursorが自動実行**: PRをマージ → ローカル更新

**所要時間**: 
- **従来の手動レビュー**: 約35分
- **Cursor自動化**: 約1分（指示を出すだけ）
- **時間短縮**: 約97%

---

## まとめ

### 成功した点

1. **AIによる完全自動化**: 「何をしたいか」を言葉で伝えるだけで、Cursorが実行まで自動化
   - Issue作成: 手動2時間 → Cursor自動5分（約96%削減）
   - PRレビュー: 手動35分 → Cursor自動1分（約97%削減）
   - ドキュメント作成: 手動数時間 → Cursor自動（指示だけ）

2. **GitHub MCP連携の活用**: Issue作成からPRマージまで、Cursor内で完結
   - コンテキストが途切れない
   - エラー防止（必要なパラメータをAIが確認）

3. **ドキュメント先行（AI自動生成）**: 約1500行のドキュメントを、指示だけで自動生成
   - 設計を先に文書化し、実装時の迷いを減らした
   - 初心者向けの詳細な手順書を自動生成

4. **シンプルな管理**: 初心者チームでも運用しやすい構造
   - AIが自動で適切なラベルを設定
   - 複雑な管理ツールが不要

5. **実践的なレビュー（AI自動化）**: ローカルでテストを自動実行し、結果をレビューコメントに反映
   - テスト実行からレビューコメント作成まで、すべて自動化
   - 品質を確保しながら、時間を大幅に短縮

### 最も重要な学び: 「指示を出すだけで良い」

**従来の開発フロー**:
- コマンドを覚える必要がある
- 手順を理解する必要がある
- エラー時に自分で調査する必要がある
- 時間がかかる

**Cursorを使った開発フロー**:
- 「何をしたいか」を言葉で伝えるだけ
- AIが自動で実行
- エラー時も自動で対処
- 時間を大幅に短縮（約97%削減）

### 実際の数値

| タスク | 従来（手動） | Cursor自動化 | 削減率 |
|--------|-------------|-------------|--------|
| Issue作成（12個） | 約2時間 | 約5分 | 96% |
| PRレビュー（1件） | 約35分 | 約1分 | 97% |
| ドキュメント作成（約1500行） | 数時間 | 指示だけ | ほぼ100% |
| コード実装（Phase 0） | 数時間 | 各フェーズで指示だけ | 大幅削減 |

### 課題と改善

1. **テストの自動化**: 手動テストから自動テストへ移行
   - **現状**: Cursorがローカルで自動テストを実行
   - **改善**: GitHub ActionsでCI/CDを構築し、PR作成時に自動でテスト実行

2. **CI/CDの構築**: デプロイプロセスの自動化
   - **現状**: デプロイは手動（予定）
   - **改善**: mainブランチへのマージで自動デプロイ

3. **コミュニケーション**: 通知やレポートの自動化
   - **現状**: SlackとGitHubのIssue/PRでコミュニケーション
   - **改善**: PRに自動でSlack通知、Issue作成時に担当者に通知

### 今後の展開

- Week 1: MVP機能の実装完了
- Week 2: 差別化機能の実装開始
- Week 3: デプロイと最終調整

**目標**: 3週間で「完璧に動く」MVPを完成させる

---

## 参考資料

### プロジェクトドキュメント
- `docs/setup/github_workflow.md`: GitHubワークフロー手順書
- `docs/setup/week1_development_guide.md`: Week1開発ガイド
- `docs/tasks/task_breakdown_week1.md`: Week1タスク分割

### 外部リソース
- [FastAPI公式ドキュメント](https://fastapi.tiangolo.com/)
- [Next.js公式ドキュメント](https://nextjs.org/docs)
- [GitHub Docs](https://docs.github.com/)

---

**作成者**: しゅんすけ  
**最終更新**: 2026年1月10日
