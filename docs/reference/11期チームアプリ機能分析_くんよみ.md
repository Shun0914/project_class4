# くんよみ（kunyomi）機能分析

## 概要
11期チームが開発した「くんよみ」- 社内ナレッジ管理システムの機能を分析したドキュメントです。

**リポジトリ**: https://github.com/Shun0914/kunyomi  
**分析ベース**: 実際のコード（GitHubリポジトリ）

---

## 技術スタック
- **フロントエンド**: Next.js 16, React 19, TypeScript, Tailwind CSS
- **バックエンド**: FastAPI, SQLAlchemy
- **データベース**: Azure Database for MySQL
- **デプロイ**: Azure App Service

---

## 実装されている主要機能（コードから確認）

### 1. ドキュメント管理機能
**エンドポイント**: `/api/documents`

- `POST /api/documents`: ドキュメント作成
  - タイトル、本文、ジャンルID、外部リンク、キーワード（最大3個）を登録
  - キーワードの自動正規化・既存チェック
  - キーワード使用回数の自動カウント
- `GET /api/documents`: ドキュメント一覧取得
- `GET /api/documents/{document_id}`: ドキュメント詳細取得
  - キーワード情報も含めて返す
- `POST /api/documents/{document_id}/view`: 閲覧数インクリメント

**コードの特徴**:
- キーワードの正規化処理（`normalize_text()`）を使用
- キーワードとドキュメントの中間テーブル（`DocumentKeyword`）で管理
- 既存キーワードの使用回数を自動インクリメント

**参考ファイル**:
- `backend/app/routers/documents.py`
- `backend/app/models/document.py`
- `backend/app/models/document_keyword.py`

---

### 2. 評価機能（役立ち度）
**エンドポイント**: `/api/documents/{document_id}/evaluate`

- `POST /api/documents/{document_id}/evaluate`: ドキュメント評価
  - リクエスト: `{ "is_helpful": true/false }`
  - 1ユーザー1ドキュメントにつき1回まで（重複は409エラー）
  - `helpful_count`と`helpfulness_score`を即時更新
  - `helpfulness_score = helpful_count / view_count`で計算

**データモデル**:
- `DocumentEvaluation`テーブル: 評価履歴を保存
- `Document.helpful_count`: 役立ったと評価された回数
- `Document.helpfulness_score`: 役立ち度スコア（0.0-1.0）

**コードの特徴**:
- 評価の重複防止（`DocumentEvaluation`でユニーク制約 `uk_document_user`）
- スコアの自動計算・更新（`helpfulness_score = helpful_count / view_count`）
- 評価と同時にスコアを更新するトランザクション処理
- 重複評価時は409エラーを返す

**参考ファイル**:
- `backend/app/routers/documents.py` (evaluate_document関数)
- `backend/app/models/document_evaluation.py`

---

### 3. 検索機能
**エンドポイント**: `/api/documents/search`

- `GET /api/documents/search?q={query}`: ドキュメント検索
  - タイトルに対するLIKE検索
  - キーワード名に対するマッチング（正規化処理あり）
  - ソート順: 有益度スコア（降順）→ 更新日時（降順）

**コードの特徴**:
- キーワードの正規化処理を検索にも適用
- 中間テーブル経由でのキーワード検索
- スコアベースのランキング表示

**参考ファイル**:
- `backend/app/routers/documents_search.py`
- `backend/app/routers/keywords.py` (normalize_text関数)

---

### 4. Q&A機能
**エンドポイント**: `/api/documents/{document_id}/qas`

- `GET /api/documents/{document_id}/qas`: QA一覧取得
- `POST /api/documents/{document_id}/qas`: 質問登録
  - ドキュメント所有者へメール通知（BackgroundTasks使用）
- `PUT /api/qas/{qa_id}/answer`: 回答登録
  - 質問者へメール通知
  - FAQフラグの設定可能

**コードの特徴**:
- バックグラウンドタスクでメール通知
- 質問・回答のステータス管理（PENDING/ANSWERED）
- FAQフラグによるよくある質問の管理

**参考ファイル**:
- `backend/app/routers/qas.py`
- `backend/app/models/qa.py`

---

### 5. ネットワークグラフ機能
**エンドポイント**: `/api/network/graph`

- `GET /api/network/graph?genre_id={id}`: ネットワークグラフ取得
  - ジャンルノードとドキュメントノードを返す
  - ジャンル階層リンクとジャンル-ドキュメントリンク
  - Obsidian風のグラフビュー用

**コードの特徴**:
- 再帰的なジャンル階層の構築
- ジャンルごとのドキュメント数カウント
- ノードとリンクの構造化されたレスポンス

**参考ファイル**:
- `backend/app/routers/network.py`
- `backend/app/schemas/network.py`

---

### 6. キーワード管理機能
**エンドポイント**: `/api/keywords`

- キーワードの正規化処理（NFKC正規化、ケースフォールディング）
- 使用回数のカウント
- 検索時の正規化マッチング

**コードの特徴**:
- `normalize_text()`関数で統一的な正規化処理
- キーワードの使用回数を自動カウント
- 検索時の正規化マッチングで柔軟な検索を実現

**参考ファイル**:
- `backend/app/routers/keywords.py`
- `backend/app/models/keyword.py`

---

### 7. ジャンル管理機能
**エンドポイント**: `/api/genres`

- 階層構造のジャンル管理
- 親ジャンル・子ジャンルの関係管理
- パスベースの階層管理

**コードの特徴**:
- 再帰的な階層構造の管理
- パス（例: "1/5/23"）による階層表現
- ジャンルごとのドキュメント数カウント

**参考ファイル**:
- `backend/app/routers/genre.py`
- `backend/app/models/genre.py`

---

## gen12への組み込み可能性

### 高優先度

#### 評価機能（役立ち度）
- **実装のしやすさ**: ⭐⭐⭐⭐⭐
- **組み込み方法**: `DocumentEvaluation`を参考に`ExpenseEvaluation`を作成
- **gen12での活用**: 各支出アイテムに対して「この買い物は役立ったか」を評価

### 中優先度

#### キーワード検索機能
- **実装のしやすさ**: ⭐⭐⭐⭐
- **組み込み方法**: `normalize_text()`を流用してキーワード検索を実装
- **gen12での活用**: 支出履歴のキーワード検索

#### カテゴリ分類機能
- **実装のしやすさ**: ⭐⭐⭐⭐
- **組み込み方法**: `genres`テーブルの構造を参考に`categories`テーブルを作成
- **gen12での活用**: 支出をカテゴリで分類（食費、交通費、書籍など）

### 低優先度

#### Q&A機能
- **実装のしやすさ**: ⭐⭐⭐
- **組み込み方法**: アプリの使い方に関するQ&A機能
- **gen12での活用**: 「予算の設定方法は？」などのQ&A

#### ネットワークグラフ機能
- **実装のしやすさ**: ⭐⭐⭐
- **組み込み方法**: 支出パターンの可視化に使用
- **gen12での活用**: 支出カテゴリの関連性を可視化

---

## 参考コード

### 評価機能の実装例
```python
# backend/app/routers/documents.py
@router.post("/api/documents/{document_id}/evaluate")
def evaluate_document(
    document_id: int,
    request: DocumentEvaluateRequest,
    db: Session = Depends(get_db),
):
    # 評価の重複チェック
    existing = db.query(DocumentEvaluation).filter(
        DocumentEvaluation.document_id == document_id,
        DocumentEvaluation.user_id == TEMP_USER_ID,
    ).first()
    if existing:
        raise HTTPException(status_code=409, detail="Already evaluated")
    
    # 評価レコード作成
    evaluation = DocumentEvaluation(
        document_id=document_id,
        user_id=TEMP_USER_ID,
        is_helpful=request.is_helpful,
    )
    db.add(evaluation)
    
    # スコア更新
    if request.is_helpful:
        doc.helpful_count += 1
    denominator = max(doc.view_count, 1)
    doc.helpfulness_score = round(doc.helpful_count / denominator, 2)
    
    db.commit()
    return doc
```

### キーワード正規化処理
```python
# backend/app/routers/keywords.py
def normalize_text(s: str) -> str:
    """
    正規化処理：
    - NFKC Normalize
    - ケースフォールディング
    """
    return unicodedata.normalize("NFKC", s).casefold()
```

---

**作成日**: 2026年1月28日  
**作成者**: しゅんすけ  
**ステータス**: 参考資料
